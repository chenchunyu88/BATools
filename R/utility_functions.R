#'  A print method for ba objects
#'  @title print \code{\link{ba}} object
#'  @param ba an object of the class ba generated by \code{\link{bafit}}
#'  @return Null. This function only prints to the screen.
#'  @export
#'  
print.ba <- function(ba) {    
    cat("BATools analysis of trait:", ba$trait, "\n")    
    cat("\nestimated fixed effects:\n")
    print(ba$betahat)
    if(!is.null(ba$sdbeta)){
      cat("\nSD\n")
      print(ba$sdbeta)
    }
    cat("\nestimated hyperparameters:\n")
    print(ba$hyper_est)
    if(!is.null(ba$eff_sample)) {
	cat("\neffective sample size for hyperparameters: \n")
	print(ba$eff_sample)
    }
}

#'  Set initial values for hyperparameters
#'  @title Set initial values for hyperparameters
#'  @param y `numeric` of phenotypes or `baData` object
#'	@param Z genotype matrix
#'  @param baobj `baData` object
#'  @param df degrees of freedom parameter
#'  @param scale scale parameter, if is `NULL` set automatically 
#'  @param vare residual variance, if is `NULL` set automatically 
#'  @param pi_snp proportion of SNP that have non-zero effect for BayesB and SSVS
#'	@param h2 hertiability
#'	@param c ratio for the smaller variance 
#'	@param model the model used for analysis, can be 'rrBLUP', 'BayesA','BayesB', or "SSVS"
#'	@param centered logical indicating if Z is centered
#'	@param from the source of scale, if it's 'rrBLUP', the scale will be adjusted for BayesA and SSVS
#'  @return a list of initial values
#'  @export
#'
set_init <- function (y, ...) {
  UseMethod("set_init", y)
}

#' @rdname set_init
#' @method set_init default
#' @export  
set_init.default <- function(y,Z,df=5,scale=NULL,vare=NULL,pi_snp=0.05,h2=0.5,c=1000,model="rrBLUP",centered=T,from=NULL) {    
  ng=rownames(Z)
  np=names(y)
  idx <- Reduce(intersect, list(ng,np))
  y=y[idx]
  Z=Z[idx,]
  if(is.null(scale)){
    if(centered){
      MSz=mean(apply(Z,2L,function(x) sum(x^2)))
    }else{
      z2=apply(Z,2L,function(x) sum(x^2))
      MSz=sum(z2)/dim(Z)[1]-sum((apply(Z,2L,mean))^2)
    }
    scale=switch(model,rrBLUP=h2*var(y)/MSz,BayesA=(df-2)*h2*var(y)/df/MSz,SSVS=c*h2*var(y)/MSz/(c+(1-pi_snp)*(1-c)),BayesB=(df-2)*h2*var(y)/df/MSz/pi_snp)
  }else{
    if(!is.null(from)){
      if(from=="rrBLUP"){
        if(model=="BayesA") scale=(df-2)/df*scale
        if(model=="SSVS") scale=c/(c+(1-pi_snp)*(1-c))*scale
      }
    }
  }

  if(is.null(vare)){
    vare=var(y)*(1-h2)*(df+2)
  }
  
	if(!(model%in%c("BayesB","SSVS"))) pi_snp=1
		
	init<-list(vare=vare,df=df,scale=scale,pi=pi_snp)
	if(model=="SSVS") init<-list(vare=vare,df=df,scale=scale,pi=pi_snp,c=c)
	init
}


  
#' @rdname set_init
#' @method set_init baData
#' @export
set_init.baData <- function(y,df=5,scale=NULL,vare=NULL,pi_snp=0.05,h2=0.5,c=1000,model="rrBLUP",centered=T,trait=1,from=NULL) {    
  pheno<-y$pheno
  geno<-y$geno
  y1=na.omit(pheno[,trait,1])
  Z=geno
  ng=rownames(Z)
  np=names(y1)
  idx <- Reduce(intersect, list(ng,np))
  y1=y1[idx]
  Z=Z[idx,]
  init=set_init(y=y1,Z=Z,df=df,scale=scale,vare=vare,pi_snp=pi_snp,h2=h2,c=c,model=model,centered=centered,from=from)
  init
}




#'  Re-center genotype matrix
#'  @title Re-center genotype matrix
#'	@param x genotype matrix or `baData` object
#'	@param method the method used for centering, `c` is centering and `s` is standardizing 
#'  @return centered genotype matrix  or `baData` object with centered genotype matrix
#'  @export
#'
std_geno <- function (x, ...) {
  UseMethod("std_geno", x)
}

#' @rdname std_geno
#' @method std_geno default
#' @export
std_geno.default <- function(x,method="s") {  
    Z=x
    if(method=="c"){
    	Zc<-apply(Z,2,function(x) (x-mean(x)))	
    }else if(method=="s"){
		p<-apply(Z,2,mean)/2
		tmp<-sweep(Z,2L,2*p,FUN="-")
		d=sapply(sqrt(2*p*(1-p)),function(x) if(x==0) x=1 else x=x,simplify=T) ###added code to check if p==0
		Zc<-sweep(tmp,2L,d,FUN="/")
	}else{stop("method should be either 'c' or 's'")}
	Zc
}


#' @rdname std_geno
#' @method std_geno baData
#' @export
std_geno.baData <- function(x,method="s") {    
  if(!is.null(x$geno)) x$geno<-std_geno(x$geno,method=method)
  else stop("The genotype must be available")
  x
}



rankMatrix<-function (x, tol = NULL, method = c("tolNorm2", "qr.R", "qrLINPACK", "qr", "useGrad", "maybeGrad"), sval = svd(x, 0, 0)$d, warn.t = TRUE) 
{
    stopifnot(length(d <- dim(x)) == 2)
    p <- min(d)
    method <- match.arg(method)
    if (useGrad <- (method %in% c("useGrad", "maybeGrad"))) {
        stopifnot(length(sval) == p, diff(sval) <= 0)
        ln.av <- log(abs(sval))
        diff1 <- diff(ln.av)
        if (method == "maybeGrad") {
            grad <- (min(ln.av) - max(ln.av))/p
            useGrad <- (min(diff1) <= min(-3, 10 * grad))
        }
    }
    if (!useGrad) {
        x.dense <- is.numeric(x) || is(x, "denseMatrix")
        if ((Meth <- method) == "qr") 
            method <- if (x.dense) 
                "qrLINPACK"
            else "qr.R"
        else Meth <- substr(method, 1, 2)
        if (Meth == "qr") {
            if (is.null(tol)) 
                tol <- max(d) * .Machine$double.eps
        }
        else {
            if (is.null(tol)) {
                if (!x.dense && missing(sval) && prod(d) >= 100000L) 
                  warning(gettextf("rankMatrix(<large sparse Matrix>, method = '%s') coerces to dense matrix.\n Probably should rather use method = 'qr' !?", 
                    method), immediate. = TRUE, domain = NA)
                stopifnot(diff(sval) <= 0)
                tol <- max(d) * .Machine$double.eps
            }
            else stopifnot((tol <- as.numeric(tol)[[1]]) >= 0)
        }
    }
    structure(if (useGrad) 
        which.min(diff1)
    else if (Meth == "qr") {
        if ((do.t <- (d[1L] < d[2L])) && warn.t) 
            warning(gettextf("rankMatrix(x, method='qr'): computing t(x) as nrow(x) < ncol(x)"))
        q.r <- qr(if (do.t) 
            t(x)
        else x, tol = tol, LAPACK = method != "qrLINPACK")
        if (x.dense && (method == "qrLINPACK")) 
            q.r$rank
        else {
            diagR <- if (x.dense) 
                diag(q.r$qr)
            else diag(q.r@R)
            d.i <- abs(diagR)
            sum(d.i >= tol * max(d.i))
        }
    }
    else sum(sval >= tol * sval[1]), method = method, useGrad = useGrad, 
        tol = if (useGrad) NA else tol)
}