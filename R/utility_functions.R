#' A print method for ba objects
#' @param ba an object of the class ba generated by bafit
#' @return Null. This function only prints to the screen.
#' @examples \dontrun{
#'  rm(list=ls())
#'  library(BATools)
#'  data("Pig")
#'  #Standardize genotype matrix
#   geno=std_geno(PigM,method="s",freq=PigAlleleFreq)
#   init=set_init("driploss",data=PigPheno,geno=geno,"id",df=5,pi_snp=0.001,h2=0.5,c=1000,model="SSVS",centered=TRUE)
#'  #or set your own starting values using 
#'  #init=list(df=5,scale=0.01,pi=1) 
#'  run_para=list(niter=2000,burnIn=1000,skip=10)
#'  print_mcmc=list(piter=500)
#'  update_para=list(df=FALSE,scale=TRUE,pi=F)
#'  op<-create.options(model="SSVS",method="MCMC",seed=1,priors=NULL,init=init,
#'                   update_para=update_para,run_para=run_para,save.at="SSVS",print_mcmc=print_mcmc)
#'  SSVS<-baFit(driploss~sex,data=PigPheno,geno=geno ,genoid = ~id,options = op,map=PigMap,GWA="Win")
#'  SSVS
#' }
#' @export
print.ba <- function(ba) {    
    cat("BATools analysis of trait:", ba$trait, "\n")    
    cat("\nestimated fixed effects:\n")
    print(ba$betahat)
    if(!is.null(ba$sdbeta)){
      cat("\nSD\n")
      print(ba$sdbeta)
    }
    cat("\nestimated hyperparameters:\n")
    print(ba$hyper_est)
    if(!is.null(ba$eff_sample)) {
	    cat("\neffective sample size for hyperparameters: \n")
	    print(ba$eff_sample)
    }
    if(!is.null(ba$train)){
      cat("\ncross-validation accuarcy: \n")
      cat(round(cor(ba$y[!ba$train],ba$yhat[!ba$train]),3))
    }
}

#'  Set initial values for hyperparameters
#' @param y character phenotypes name 
#' @param data data.frame containing phenotypes
#' @param geno genotype matrix
#' @param genoid character of the column name of `data` representing the id related the rowname of `geno`
#' @param df degrees of freedom parameter
#' @param scale scale parameter, if is `NULL` set automatically 
#' @param vare residual variance, if is `NULL` set automatically 
#' @param g starting values for SNP effects, if is `NULL` will start from 
#' @param beta starting values for fixed effects, 
#' @param pi_snp proportion of SNP that have non-zero effect for BayesB and SSVS, default is 0.05 
#' @param h2 hertiability
#' @param c ratio for the smaller variance for SSVS
#' @param model the model used for analysis, can be c("rrBLUP","GBLUP", "BayesA","BayesB", "SSVS","ssGBLUP", "ssBayesA","ssBayesB", "ssSSVS","anteBayesA","anteBayesB")
#' @param centered logical indicating if Z is centered
#' @param from the source of scale, if it's 'rrBLUP', the scale will be adjusted for BayesA and SSVS
#' @return a list of initial values
#' @examples \dontrun{
#'  data(Pig)
#'  init=set_init("driploss",data=PigPheno,geno=geno,genoid = "id",model="SSVS",centered=TRUE)
#' }
#' @export
set_init <- function(y,data,geno,genoid,df=5,scale=NULL,vare=NULL,g=NULL,
                     beta=NULL,pi_snp=0.05,post_prob=NULL,h2=0.5,c=1000,
                     model=c("rrBLUP","GBLUP", "BayesA","BayesB", "SSVS","ssGBLUP", "ssBayesA","ssBayesB", "ssSSVS","anteBayesA","anteBayesB"),
                     varGenetic=NULL,centered=T,from=NULL) {    
  if(!is.character(y)) stop("Phenotype name has to be an character")
  model<-match.arg(model)
  
  id<-model.frame(as.formula(paste0("~",genoid)),data=data,na.action = na.pass)
  id <- eval(id, parent.frame())
  id <-as.character(t(id))
  
  if(substr(model,1,2)=="ss"){
    idgeno<-id[which(id %in% rownames(geno))]
    Z<-geno[idgeno,]  
  }else(
    Z<-geno[id,]
  )
  
  
  data<- data %>% filter (id %in% rownames(Z))
  mf <- model.frame(as.formula(paste0(y,"~0")), data = data, na.action = na.pass)
  mf <- eval(mf, parent.frame())
  y <- model.response(mf)
  
  if(is.null(scale)){
    if(centered){
      z2=apply(Z,2,function(x) sum(x^2))
      sumMeanSq= sum((apply(Z,2,mean))^2)
      MSz=sum(z2)/dim(Z)[1]-sumMeanSq
    }else{
      zc=std_geno(Z,method="c")
      z2=apply(zc,2,function(x) sum(x^2))
      sumMeanSq= sum((apply(zc,2,mean))^2)
      MSz=sum(z2)/dim(zc)[1]-sumMeanSq
    }
    tmpSigmaG=rrBLUP=h2*var(y)/MSz
    scale=switch(model,rrBLUP=h2*var(y)/MSz,BayesA=(df-2)*h2*var(y)/df/MSz,
                 SSVS=c*h2*var(y)/MSz/(c+(1-pi_snp)*(1-c)),BayesB=(df-2)*h2*var(y)/df/MSz/pi_snp,
                 ssBayesA=(df-2)*h2*var(y)/df/MSz,
                 ssSSVS=c*h2*var(y)/MSz/(c+(1-pi_snp)*(1-c)),ssBayesB=(df-2)*h2*var(y)/df/MSz/pi_snp)
  }else{
    if(!is.null(from)){
      if(from %in% c("rrBLUP","GBLUP")){
        tmpSigmaG=scale
        if(model %in% c("BayesA","ssBayesA")) scale=(df-2)/df*scale
        if(model %in% c("BayesB","ssBayesB")) scale=(df-2)/df*scale/pi_snp
        if(model %in% c("SSVS","ssSSVS")) scale=c/(c+(1-pi_snp)*(1-c))*scale
      }
    }
  }

  if(is.null(vare)){
    vare= var(y)*(1-h2)*(df+2) #crossprod(y)/length(y)
  }
  
	if(!(model%in%c("BayesB","ssBayesB","SSVS","ssSSVS"))) pi_snp=1
	
  if(substr(model,1,2)=="ss"){
    if(is.null(varGenetic)) varGenetic=tmpSigmaG
    init<-list(vare=vare,df=df,scale=scale,g=g,beta=beta,pi=pi_snp,varGenetic=varGenetic)
    if(model %in% c("SSVS","ssSSVS")) init<-list(vare=vare,df=df,scale=scale,g=g,beta=beta,pi=pi_snp,post_prob=post_prob,c=c,varGenetic=varGenetic)
  }else{
    init<-list(vare=vare,df=df,scale=scale,g=g,beta=beta,pi=pi_snp)
    if(model %in% c("SSVS","ssSSVS")) init<-list(vare=vare,df=df,scale=scale,g=g,beta=beta,pi=pi_snp,post_prob=post_prob,c=c)
    
  }	
  init
}




#' 
#' Re-center genotype matrix
#' @title Re-center genotype matrix
#' @param x genotype matrix or `baData` object
#' @param method the method used for centering, `c` is centering and `s` is standardizing 
#' @param freq allele frequency of the one coded as 1, if not supplied, will use the frequency in \code{x}
#' @return centered genotype matrix  or `baData` object with centered genotype matrix
#' @examples \dontrun{
#'  data("Pig")
#'  #Standardize genotype matrix with the allele frequency in F0
#'  geno=std_geno(PigM,method="s",freq=PigAlleleFreq)
#' }
#' @export
std_geno <- function(x,method=c("s","c"),freq=NULL) {  
    Z=x
    method<-match.arg(method)
    if(method=="c"){
    	Zc<-apply(Z,2,function(x) (x-mean(x)))	
    }else if(method=="s"){
		  if(is.null(freq)) p<-apply(Z,2,mean)/2 else p<-freq
		  tmp<-sweep(Z,2L,2*p,FUN="-")
		  #d=sapply(sqrt(2*p*(1-p)),function(x) if(x==0) x=1 else x=x,simplify=T) ###added code to check if p==0
		  d=sqrt(sum(2*p*(1-p)))
		  Zc<-tmp/d #sweep(tmp,2L,d,FUN="/")
	}else{stop("method should be either 'c' or 's'")}
	Zc
}


#' Quickly create cross-validation folds
#' @param data dataframe contain the phenotypes
#' @param k number of folds
#' @param y charactor of the trait name
#' @return data.frame of the all traits including the cross-validation folds
#' @examples \dontrun{
#' set.seed(1234)
#' PigPheno=createCV(data = PigPheno,k=5,"driploss")
#' }
#' @export
createCV<-function(data,k=5,y){
  cln<-colnames(data)
  coli=which(substr(cln,1,2)!="cv")
  data<-data[,coli]
  if(is.null(y)){
    y=data[,1]
  }else{
    mf <- model.frame(as.formula(paste0(y,"~0")), data = data, na.action = na.pass)
    mf <- eval(mf, parent.frame())
    y <- model.response(mf)
  }
  cvs<-createFolds(y,k=k,list=F)
  cln<-colnames(data)
  newdata<-c()
  for(i in 1:k){
    newdata<-cbind(newdata,cvs!=i)
  }
  colnames(newdata)=c(paste0("cv",1:k))
  cbind(data,newdata)
}


#' Create Manhattan plot for posterior probability based models
#' @param ba an object of the class \code{ba} generated by baFit
#' @param type can be c("SNP","Win") for single SNP or window based Manhattan plot 
#' @param col color for the Manhattan plot 
#' @return Null. This function only prints to the screen.
#' @examples \dontrun{
#'  rm(list=ls())
#'  library(BATools)
#'  data("Pig")
#'  #Standardize genotype matrix
#   geno=std_geno(PigM,method="s",freq=PigAlleleFreq)
#   init=set_init("driploss",data=PigPheno,geno=geno,"id",df=5,pi_snp=0.001,h2=0.5,c=1000,model="SSVS",centered=TRUE)
#'  #or set your own starting values using 
#'  #init=list(df=5,scale=0.01,pi=1) 
#'  run_para=list(niter=2000,burnIn=1000,skip=10)
#'  print_mcmc=list(piter=500)
#'  update_para=list(df=FALSE,scale=TRUE,pi=F)
#'  op<-create.options(model="SSVS",method="MCMC",seed=1,priors=NULL,init=init,
#'                   update_para=update_para,run_para=run_para,save.at="SSVS",print_mcmc=print_mcmc)
#'  SSVS<-baFit(driploss~sex,data=PigPheno,geno=geno ,genoid = ~id,options = op,map=PigMap,GWA="Win")
#'  par(mfrow=c(1,2))
#'  man_plot_prob(SSVS)
#'  man_plot_prob(SSVS,type="Win")
#' }
#' @export
man_plot_prob<-function(ba,type=c("SNP","Win"), col = c("black", "red"),...){
  type<-match.arg(type)
  if(ba$model %in% c("rrBLUP","BayesA","anteBayesA","ssBayesA") && type=="SNP"){
    ba$pvalue=ba$bpvalue
    man_plot_pvalue(ba)
  }else{
    if(ba$GWA!="Win" && type=="Win") stop("Window based GWA is require to create plot for window based approach, redo analysis with GWA=Win")
    if(type=="SNP"){
      p<-ba$prob
      Chromsome_id=ba$map$chr
    }
    if(type=="Win"){
      p=ba$Wprob
      Chromsome_id=ba$Wchr
    }
    plot(p, pch = 20, col = col[(Chromsome_id%%2) + 1], ylab = "Posterior probability", xlab = "Chromsome",  axes = F,...)
    axis(2)
    lns <- (by(Chromsome_id,Chromsome_id , length))
    axis(1, at = c(0, cumsum(lns)[-length(lns)]) + as.vector(lns/2), labels = names(lns))
    box()
  }
  #abline(h = 0.9, lwd = 2, col = "green")
}


#' Create Manhattan plot for pvalue based models
#' @param ba an object of the class \code{ba} generated by baFit
#' @param type can be c("SNP","Win") for single SNP or window based Manhattan plot 
#' @param col color for the Manhattan plot 
#' @return Null. This function only prints to the screen.
#' @examples \dontrun{
#'  rm(list=ls())
#'  library(BATools)
#'  data("Pig")
#'  #Standardize genotype matrix
#   geno=std_geno(PigM,method="s",freq=PigAlleleFreq)
#   init=set_init("driploss",data=PigPheno,geno=geno,"id",df=5,pi_snp=1,h2=0.5,c=NULL,model="GBLUP",centered=TRUE)
#'  run_para=list(maxiter=100)
#'  update_para=list(df=FALSE,scale=TRUE,pi=FALSE)
#'  op<-create.options(model="GBLUP",method="REML",priors=NULL,init=init,
#'                   update_para=update_para,run_para=run_para,save.at="GBLUP",print_mcmc=NULL)
#'  gblup<-baFit(driploss~sex,data=PigPheno,geno=geno ,genoid = ~id,options = op,map=PigMap,GWA="SNP")
#'  par(mfrow=c(1,2))
#'  man_plot_pvalue(gblup)
#'  man_plot_pvalue(gblup,type="Win")
#' }
#' @export
man_plot_pvalue<-function(ba,type=c("SNP","Win"), col = c("black", "red"),ylim=c(0,12),...){
  type<-match.arg(type)
  if(ba$GWA!="Win" && type=="Win") stop("Window based GWA is require to create plot for window based approach, redo analysis with GWA=Win")
  if(type=="SNP"){
    p<-ba$pvalue
    Chromsome_id=ba$map$chr
  }
  if(type=="Win"){
    p=ba$Wpvalue
    Chromsome_id=ba$Wchr
  }
  plot(-log(p,10), pch = 20, col = col[(Chromsome_id%%2) + 1], ylab = "-log10-pvalue", xlab = "Chromsome",  axes = F,ylim = ylim,...)
  axis(2)
  lns <- (by(Chromsome_id,Chromsome_id , length))
  axis(1, at = c(0, cumsum(lns)[-length(lns)]) + as.vector(lns/2), labels = names(lns))
  box()
  threshold=ifelse(ba$model %in%c("GBLUP","rrBLUP","ssGBLUP") ,0.05/length(p),0.05)
  abline(h = -log(threshold, 10), lwd = 2, col = "green")
}


get_full_rank_X<-function(X,y){
  
  n <- length(y)
  Xcolnames <- dimnames(X)[[2]]
  Xrownames <-rownames(X)
  if(is.null(Xcolnames)) {
    Xcolnames <- paste("X.column",c(1:dim(as.matrix(X))[2]),sep="")
  }
  
  X <- matrix(X, n, length(X)/n)
  XtX=crossprod(X)
  qr <- qr(XtX)
  rankQ <- n-qr$rank
  if(qr$rank) {
    X <- matrix(X[, qr$pivot[1:qr$rank]],n,qr$rank)
    Xcolnames <- Xcolnames[qr$pivot[1:qr$rank]]
  } else {
    cat("\nERROR: X has rank 0\n\n")
  }
  colnames(X)=Xcolnames
  rownames(X)=Xrownames
  return(X)
}
