#' A print method for ba objects
#' @param ba an object of the class ba generated by bafit
#' @return Null. This function only prints to the screen.
#' @export
print.ba <- function(ba) {    
    cat("BATools analysis of trait:", ba$trait, "\n")    
    cat("\nestimated fixed effects:\n")
    print(ba$betahat)
    if(!is.null(ba$sdbeta)){
      cat("\nSD\n")
      print(ba$sdbeta)
    }
    cat("\nestimated hyperparameters:\n")
    print(ba$hyper_est)
    if(!is.null(ba$eff_sample)) {
	    cat("\neffective sample size for hyperparameters: \n")
	    print(ba$eff_sample)
    }
    if(!is.null(ba$train)){
      cat("\ncross-validation accuarcy: \n")
      cat(round(cor(ba$y[!ba$train],ba$yhat[!ba$train]),3))
    }
}

#'  Set initial values for hyperparameters
#' @param y character phenotypes name 
#' @param data data.frame containing phenotypes
#' @param geno genotype matrix
#' @param genoid character of the column name of `data` representing the id related the rowname of `geno`
#' @param df degrees of freedom parameter
#' @param scale scale parameter, if is `NULL` set automatically 
#' @param vare residual variance, if is `NULL` set automatically 
#' @param g starting values for SNP effects, if is `NULL` will start from 
#' @param beta starting values for fixed effects, 
#' @param pi_snp proportion of SNP that have non-zero effect for BayesB and SSVS, default is 0.05 
#' @param h2 hertiability
#' @param c ratio for the smaller variance for SSVS
#' @param model the model used for analysis, can be 'rrBLUP',"GBLUP", 'BayesA','BayesB', or "SSVS", for single step or antedependence model use the base model
#' @param centered logical indicating if Z is centered
#' @param from the source of scale, if it's 'rrBLUP', the scale will be adjusted for BayesA and SSVS
#' @return a list of initial values
#' @export
set_init <- function(y,data,geno,genoid,df=5,scale=NULL,vare=NULL,g=NULL,beta=NULL,pi_snp=0.05,post_prob=NULL,h2=0.5,c=1000,model=c("rrBLUP","GBLUP", "BayesA","BayesB", "SSVS"),centered=T,from=NULL) {    
  if(!is.character(y)) stop("Phenotype name has to be an character")
  model<-match.arg(model)
  
  id<-model.frame(as.formula(paste0("~",genoid)),data=data,na.action = na.pass)
  id <- eval(id, parent.frame())
  id <-as.character(t(id))
  
  Z=geno[id,]
  
  data<- data %>% filter (id %in% rownames(Z))
  mf <- model.frame(as.formula(paste0(y,"~0")), data = data, na.action = na.pass)
  mf <- eval(mf, parent.frame())
  y <- model.response(mf)
  
  if(is.null(scale)){
    if(centered){
      z2=apply(Z,2,function(x) sum(x^2))
      sumMeanSq= sum((apply(Z,2,mean))^2)
      MSz=sum(z2)/dim(Z)[1]-sumMeanSq
    }else{
      zc=std_geno(Z,method="c")
      z2=apply(zc,2,function(x) sum(x^2))
      sumMeanSq= sum((apply(zc,2,mean))^2)
      MSz=sum(z2)/dim(zc)[1]-sumMeanSq
    }
    scale=switch(model,rrBLUP=h2*var(y)/MSz,BayesA=(df-2)*h2*var(y)/df/MSz,
                 SSVS=c*h2*var(y)/MSz/(c+(1-pi_snp)*(1-c)),BayesB=(df-2)*h2*var(y)/df/MSz/pi_snp)
  }else{
    if(!is.null(from)){
      if(from %in% c("rrBLUP","GBLUP")){
        if(model=="BayesA") scale=(df-2)/df*scale
        if(model=="BayesB") scale=(df-2)/df*scale/pi_snp
        if(model=="SSVS") scale=c/(c+(1-pi_snp)*(1-c))*scale
      }
    }
  }

  if(is.null(vare)){
    vare= var(y)*(1-h2)*(df+2) #crossprod(y)/length(y)
  }
  
	if(!(model%in%c("BayesB","SSVS"))) pi_snp=1
		
	init<-list(vare=vare,df=df,scale=scale,g=g,beta=beta,pi=pi_snp)
	if(model=="SSVS") init<-list(vare=vare,df=df,scale=scale,g=g,beta=beta,pi=pi_snp,post_prob=post_prob,c=c)
	init
}




#' 
#' Re-center genotype matrix
#' @title Re-center genotype matrix
#' @param x genotype matrix or `baData` object
#' @param method the method used for centering, `c` is centering and `s` is standardizing 
#' @return centered genotype matrix  or `baData` object with centered genotype matrix
#' @export
std_geno <- function(x,method=c("s","c"),freq=NULL) {  
    Z=x
    method<-match.arg(method)
    if(method=="c"){
    	Zc<-apply(Z,2,function(x) (x-mean(x)))	
    }else if(method=="s"){
		  if(is.null(freq)) p<-apply(Z,2,mean)/2 else p<-freq
		  tmp<-sweep(Z,2L,2*p,FUN="-")
		  #d=sapply(sqrt(2*p*(1-p)),function(x) if(x==0) x=1 else x=x,simplify=T) ###added code to check if p==0
		  d=sqrt(sum(2*p*(1-p)))
		  Zc<-tmp/d #sweep(tmp,2L,d,FUN="/")
	}else{stop("method should be either 'c' or 's'")}
	Zc
}


#' Quickly create cross-validation folds
#' @param data dataframe contain the phenotypes
#' @param k number of folds
#' @param y charactor of the trait name
#' @return data.frame of the all traits including the cross-validation folds
#' @export
createCV<-function(data,k=5,y){
  cln<-colnames(data)
  coli=which(substr(cln,1,2)!="cv")
  data<-data[,coli]
  if(is.null(y)){
    y=data[,1]
  }else{
    mf <- model.frame(as.formula(paste0(y,"~0")), data = data, na.action = na.pass)
    mf <- eval(mf, parent.frame())
    y <- model.response(mf)
  }
  cvs<-createFolds(y,k=k,list=F)
  cln<-colnames(data)
  newdata<-c()
  for(i in 1:k){
    newdata<-cbind(newdata,cvs!=i)
  }
  colnames(newdata)=c(paste0("cv",1:k))
  cbind(data,newdata)
}

#' @export
man_plot_prob<-function(ba,type=c("SNP","Win"), col = c("black", "red"),...){
  type<-match.arg(type)
  if(ba$GWA!="Win" && type=="Win") stop("Window based GWA is require to create plot for window based approach, redo analysis with GWA=Win")
  if(type=="SNP"){
    p<-ba$prob
    Chromsome_id=ba$map$chr
  }
  if(type=="Win"){
    p=ba$Wprob
    Chromsome_id=ba$Wchr
  }
  plot(p, pch = 20, col = col[(Chromsome_id%%2) + 1], ylab = "Posterior probability", xlab = "Chromsome",  axes = F,...)
  axis(2)
  lns <- (by(Chromsome_id,Chromsome_id , length))
  axis(1, at = c(0, cumsum(lns)[-length(lns)]) + as.vector(lns/2), labels = names(lns))
  box()
  #abline(h = 0.9, lwd = 2, col = "green")
}


#' @export
man_plot_pvalue<-function(ba,type=c("SNP","Win"), col = c("black", "red"),ylim=c(0,12),...){
  type<-match.arg(type)
  if(ba$GWA!="Win" && type=="Win") stop("Window based GWA is require to create plot for window based approach, redo analysis with GWA=Win")
  if(type=="SNP"){
    p<-ba$pvalue
    Chromsome_id=ba$map$chr
  }
  if(type=="Win"){
    p=ba$Wpvalue
    Chromsome_id=ba$Wchr
  }
  plot(-log(p,10), pch = 20, col = col[(Chromsome_id%%2) + 1], ylab = "-log10-pvalue", xlab = "Chromsome",  axes = F,ylim = ylim,...)
  axis(2)
  lns <- (by(Chromsome_id,Chromsome_id , length))
  axis(1, at = c(0, cumsum(lns)[-length(lns)]) + as.vector(lns/2), labels = names(lns))
  box()
  threshold=ifelse(ba$model %in%c("GBLUP","rrBLUP","ssGBLUP") ,0.05/length(p),0.05)
  abline(h = -log(threshold, 10), lwd = 2, col = "green")
}


get_full_rank_X<-function(X,y){
  
  n <- length(y)
  Xcolnames <- dimnames(X)[[2]]
  Xrownames <-rownames(X)
  if(is.null(Xcolnames)) {
    Xcolnames <- paste("X.column",c(1:dim(as.matrix(X))[2]),sep="")
  }
  
  X <- matrix(X, n, length(X)/n)
  XtX=crossprod(X)
  qr <- qr(XtX)
  rankQ <- n-qr$rank
  if(qr$rank) {
    X <- matrix(X[, qr$pivot[1:qr$rank]],n,qr$rank)
    Xcolnames <- Xcolnames[qr$pivot[1:qr$rank]]
  } else {
    cat("\nERROR: X has rank 0\n\n")
  }
  colnames(X)=Xcolnames
  rownames(X)=Xrownames
  return(X)
}
